#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'English'

ETAG_SIZE = 8
BUILD_DIR = 'build'
PUBLID_DIR = 'public'
PUBLIC_FILES_JSON = 'build/files.json'
NOW = Time.now.to_i
DONT_RENAME = %r|/lib.index.[^.]{8,16}.mjs|.freeze

cmd = ARGV.join(' ')
prog = __FILE__.split('/').last

def hours_age_of_file(filepath)
  content = run_command("stat -c %Y '#{filepath}'")
  ((content.to_i - NOW) / 60).to_i
end

def run_command(cmd)
  warn "--- #{cmd}"
  content = `#{cmd}`.strip
  return content if $CHILD_STATUS.success?

  warn "!!! Failed with exit #{$CHILD_STATUS.exitstatus}: #{cmd}"
end

def get_env(key)
  ENV.key?(key) || raise("!!! Env key not found: #{key}")
  ENV[key]
end

def update_files_uploaded
  bucket = get_env('BUCKET_NAME')
  up_files = "tmp/#{bucket}.uploaded_files.json"
  raw_content = run_command("mc ls --no-color --recursive --json '#{bucket}/#{bucket}' ")
  new_content = "[#{raw_content.gsub(/}$(?!\Z)/, '},')}]"
  File.write(up_files, new_content)
  warn "--- wrote: #{up_files}"
end

def find_files(dir, ext)
  raw = `find "#{dir}" -type f #{ext}`
  exit 2 unless $CHILD_STATUS.success?
  raw.strip.split("\n")
end # def

def raw_file_list(dir = BUILD_DIR)
  find_files(dir, "-not -name '.*'")
end # def

def strip_build_path(raw)
  raw.sub(%r{/?build/}, '/')
end

def add_etag_to_file_name(etag, path)
  return path if path[DONT_RENAME]

  pieces = path.split('/')
  last = pieces.pop
  pieces.push("#{etag[0..ETAG_SIZE]}.#{last}")
  pieces.join('/')
end

def mime_type(fname)
  content = `da www mime "#{fname}"`.strip
  raise "!!! Could not determine mime type for: #{fname}" unless $CHILD_STATUS.success?

  content
end

def quick_file_info(fname)
  { etag: "#{NOW}-#{fname}",
    public_path: strip_build_path(fname) }
end

def file_info(fname)
  etag = `md5sum "#{fname}"`.strip.split.first
  { etag: etag,
    public_path: add_etag_to_file_name(etag, strip_build_path(fname)) }
end

def build_mjs(bun_files = find_files('build', "-name '*.mts' -and -not -name '*.html.mts' "))
  if bun_files.empty?
    warn '--- No .mts files found.'
    return false
  end

  warn "--- TS files: #{bun_files.inspect}"
  system(
    'bun', 'build', '--target', 'browser',
    '--outdir', 'build/section', '--splitting',
    '--chunk-naming', '[dir]/lib.[name].[hash].mjs',
    '--entry-naming', '[dir]/[name].mjs', *bun_files
  )
  bun_files.each { |x| File.unlink x }
end # def

def build_public_files_json
  public_files = raw_file_list.each_with_object({}) do |fname, memo|
    memo[strip_build_path(fname)] = file_info(fname)
  end
  File.write(PUBLIC_FILES_JSON, JSON.pretty_generate(public_files))
  warn "--- Wrote: #{PUBLIC_FILES_JSON}"
end # def

def static_build(files = raw_file_list)
  mts_files = []
  files.each do |raw_file|
    case raw_file
    when %r{section/base/.+\.css$}
      next

    when /.html.mts$/
      new_file = raw_file.sub(/.html.mts/, '.html')
      warn "--- Compiling #{raw_file} -> #{new_file}"
      output = `bun run #{raw_file}`.strip
      exit 2 unless $CHILD_STATUS.success?
      File.write(new_file, output)
      File.unlink(raw_file)

    when %r{section/.+\.css$}
      warn "--- Compiling #{raw_file}"
      tmp_file = "#{raw_file}.tmp"
      system(%( bun x lightningcss --minify --bundle "#{raw_file}" -o "#{tmp_file}" ))
      File.rename(tmp_file, raw_file)

    when /.mts$/
      mts_files.push raw_file
    end # case
  end # each

  build_mjs mts_files unless mts_files.empty?
end # def static_build

case cmd
when '-h', '--help', 'help'
  puts "#{prog} -h|--help|help  --  Show this message."
  puts "#{prog} static upload"
  puts "#{prog} static build"
  puts "#{prog} static build rename -- Add etag to filename."
  puts "#{prog} update files uploaded"

when 'static build'
  static_build

when /static build file (.+)/
  static_build [raw_file_name.sub(PUBLID_DIR, BUILD_DIR)]

when 'static build rename'
  public_files = raw_file_list.each_with_object({}) do |fname, memo|
    memo[strip_build_path(fname)] = file_info(fname)
  end

  Dir.chdir(BUILD_DIR) do
    public_files.each do |origin, info|
      next if origin[/\.html$/]

      warn "--- Changing static file paths: #{origin} -> #{info[:public_path]}"
      content = File.read(File.join('.', origin))
      new_content = content.gsub(%r@(src|href)="([^"]+)"@) do |x|
        attr = Regexp.last_match(1)
        old_path = Regexp.last_match(2)
        path_info = public_files[old_path]
        if path_info
          %(#{attr}="#{path_info[:public_path]}")
        else
          x
        end
      end
      File.write(File.join('.', info[:public_path]), new_content)
      File.unlink(File.join('.', origin))
    end
  end

  File.write(PUBLIC_FILES_JSON, JSON.pretty_generate(public_files))
  warn "--- Wrote: #{PUBLIC_FILES_JSON}"

when 'update files uploaded'
  update_files_uploaded

when 'static upload'
  bucket = get_env('BUCKET_NAME')
  uploaded_files = begin
    up_files = "tmp/#{bucket}.uploaded_files.json"
    unless File.exist?(up_files)
      raw = run_command(%( mc ls --recursive --no-color '#{bucket}/#{bucket}' | tr -s ' ' | cut -d' ' -f6 ))
      File.write(up_files, raw.strip)
    end # if
    File.read(up_files).split("\n")
  end # uploaded_files

  target_files = raw_file_list
                 .map { |x| x.sub(BUILD_DIR, '') }
                 .reject { |curr| uploaded_files.include?(curr) }

  puts target_files.inspect
  puts target_files.size
  # filter out files that have been uploaded
  # upload files
  #   get mime type
else
  warn "!!! Unknown command: #{cmd}"
  exit 1
end # case
