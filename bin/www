#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'English'

ETAG_SIZE = 8
BUILD_DIR = 'build'
PUBLID_DIR = 'public'
PUBLIC_FILES_JSON = 'build/files.json'
NOW = Time.now.to_i
DONT_RENAME = %r|/lib.index.[^.]{8,16}.mjs|.freeze

cmd = ARGV.join(' ')
prog = __FILE__.split('/').last

class BUILD
  class << self
    def file_list
      find_files(BUILD, "-not -name '.*'")
    end
  end # class
end # class BUILD

class FILES
  class << self
    def bucket_name
      @bucket_name ||= get_env('BUCKET_NAME')
    end

    def mime_type(fname)
      run_command("da www mime '#{fname}'")
    end

    def etag(fname)
     `md5sum "#{fname}"`.strip.split.first
    end

    def key_name(filename)
      filename.gsub(%r{(#{BUILD_DIR}|#{PUBLID_DIR}|\.)/}, '')
    end

    def files_uploaded_json
      @files_uploaded_json ||= "tmp/#{bucket_name}.uploaded_files.json"
    end

    def uploaded
      @uploaded ||= begin
                      File.write(files_uploaded_json, '[]') unless File.exist?(files_uploaded_json)
                      update_files_uploaded_json if hours_age_of_file(files_uploaded_json) > 6
                      raw = JSON.parse File.read(files_uploaded_json)
                      raw.each_with_object({}) { |info, o| o[info['key']] = info }
                    end
    end

    def update_files_uploaded_json
      raw = run_command("mc ls --no-color --recursive --json '#{bucket_name}/#{bucket_name}' ")
      new_content = raw.split("\n").map { |x| JSON.parse(x) }
      File.write(files_uploaded_json, JSON.pretty_generate(new_content))
      warn "--- wrote: #{up_files}"
    end


    def uploaded?(key, filepath)
      uploaded[key] && uploaded[key]['etag'] == FILES.etag(filepath)
    end

    def upload(filelist)
      filelist.each do |file|
        k = FILES.key_name(file)
        etag = FILES.etag(file)
        already_up = uploaded[k] && uploaded[k]['etag'] == etag
        next if already_up

        mime = FILES.mime_type(file)
        system_command(%(
          bun x wrangler r2 object put '#{FILES.bucket_name}/#{key}' --file '#{file}' --content-type '#{mime}'"
        ))
      end # each file
    end # def
  end # class
end # class

def hours_age_of_file(filepath)
  content = run_command("stat -c %Y '#{filepath}'")
  ((content.to_i - NOW) / 60).to_i
end

def system_command(cmd)
  warn "--- #{cmd}"
  system(cmd.strip)
  return content if $CHILD_STATUS.success?

  warn "!!! Failed with exit #{$CHILD_STATUS.exitstatus}: #{cmd}"
end

def run_command(raw_cmd)
  cmd = raw_cmd.strip
  warn "--- #{cmd}"
  content = `#{cmd}`
  return content if $CHILD_STATUS.success?

  warn "!!! Failed with exit #{$CHILD_STATUS.exitstatus}: #{cmd.inspect}"
  content.strip
end

def get_env(key)
  ENV.key?(key) || raise("!!! Env key not found: #{key}")
  ENV[key]
end

def find_files(dir, ext)
  raw = `find "#{dir}" -type f #{ext}`
  exit 2 unless $CHILD_STATUS.success?
  raw.strip.split("\n")
end # def

def raw_file_list(dir = BUILD_DIR)
  find_files(dir, "-not -name '.*'")
end # def

def strip_build_path(raw)
  raw.sub(%r{/?build/}, '/')
end

def add_etag_to_file_name(etag, path)
  return path if path[DONT_RENAME]

  pieces = path.split('/')
  last = pieces.pop
  pieces.push("#{etag[0..ETAG_SIZE]}.#{last}")
  pieces.join('/')
end


def quick_file_info(fname)
  { etag: "#{NOW}-#{fname}",
    public_path: strip_build_path(fname) }
end

def file_info(fname)
  etag = FILES.etag(fname)
  { etag: etag,
    public_path: add_etag_to_file_name(etag, strip_build_path(fname)) }
end

def build_mjs(bun_files = find_files('build', "-name '*.mts' -and -not -name '*.html.mts' "))
  if bun_files.empty?
    warn '--- No .mts files found.'
    return false
  end

  warn "--- TS files: #{bun_files.inspect}"
  system(
    'bun', 'build', '--target', 'browser',
    '--outdir', 'build/section', '--splitting',
    '--chunk-naming', '[dir]/lib.[name].[hash].mjs',
    '--entry-naming', '[dir]/[name].mjs', *bun_files
  )
  bun_files.each { |x| File.unlink x }
end # def

def build_public_files_json
  public_files = raw_file_list.each_with_object({}) do |fname, memo|
    memo[strip_build_path(fname)] = file_info(fname)
  end
  File.write(PUBLIC_FILES_JSON, JSON.pretty_generate(public_files))
  warn "--- Wrote: #{PUBLIC_FILES_JSON}"
end # def

def static_build(files = raw_file_list)
  mts_files = []
  files.each do |raw_file|
    case raw_file
    when %r{section/base/.+\.css$}
      next

    when /.html.mts$/
      new_file = raw_file.sub(/.html.mts/, '.html')
      warn "--- Compiling #{raw_file} -> #{new_file}"
      output = `bun run #{raw_file}`.strip
      exit 2 unless $CHILD_STATUS.success?
      File.write(new_file, output)
      File.unlink(raw_file)

    when %r{section/.+\.css$}
      warn "--- Compiling #{raw_file}"
      tmp_file = "#{raw_file}.tmp"
      system(%( bun x lightningcss --minify --bundle "#{raw_file}" -o "#{tmp_file}" ))
      File.rename(tmp_file, raw_file)

    when /.mts$/
      mts_files.push raw_file
    end # case
  end # each

  build_mjs mts_files unless mts_files.empty?
end # def static_build

case cmd
when '-h', '--help', 'help'
  puts "#{prog} -h|--help|help  --  Show this message."
  puts "#{prog} static upload"
  puts "#{prog} static build"
  puts "#{prog} static build rename -- Add etag to filename."
  puts "#{prog} update files uploaded"

when 'static build'
  static_build

when /static build file (.+)/
  static_build [raw_file_name.sub(PUBLID_DIR, BUILD_DIR)]

when 'static build rename'
  public_files = raw_file_list.each_with_object({}) do |fname, memo|
    memo[strip_build_path(fname)] = file_info(fname)
  end

  Dir.chdir(BUILD_DIR) do
    public_files.each do |origin, info|
      next if origin[/\.html$/]

      warn "--- Changing static file paths: #{origin} -> #{info[:public_path]}"
      content = File.read(File.join('.', origin))
      new_content = content.gsub(%r@(src|href)="([^"]+)"@) do |x|
        attr = Regexp.last_match(1)
        old_path = Regexp.last_match(2)
        path_info = public_files[old_path]
        if path_info
          %(#{attr}="#{path_info[:public_path]}")
        else
          x
        end
      end
      File.write(File.join('.', info[:public_path]), new_content)
      File.unlink(File.join('.', origin))
    end
  end

  File.write(PUBLIC_FILES_JSON, JSON.pretty_generate(public_files))
  warn "--- Wrote: #{PUBLIC_FILES_JSON}"

when 'static update uploaded file list'
  update_files_uploaded

when 'static upload'
  FILES.upload(BUILD.file_list)
else
  warn "!!! Unknown command: #{cmd}"
  exit 1
end # case
