#!/usr/bin/env ruby
# frozen_string_literal: true

require 'json'
require 'English'
require 'fileutils'

require_relative '../lib/OS'
require_relative '../lib/FILES'
require_relative '../lib/BUILD'
require_relative '../lib/CLI'

PUBLIC_FILES_JSON = 'build/files.json'
NOW = Time.now.to_i
DONT_RENAME = %r|/lib.index.[^.]{8,16}.mjs|.freeze

# =============================================================================
# ===================== PROCESS COMMAND ARGUMENTS =============================
# =============================================================================

cmd = ARGV.join(' ')
prog = __FILE__.split('/').last

case cmd
when '-h', '--help', 'help'
  CLI.puts "#{prog} -h|--help|help  --  Show this message."
  CLI.puts "#{prog} build  settings - build/settings.json"
  CLI.puts "#{prog} build  [file FILEPATH]"
  CLI.puts "#{prog} upload [file FILEPATH]"
  CLI.puts "#{prog} download pure.css to [DIR]"
  CLI.puts "#{prog} template from [FILE} to [DIR] with (KEY=VAL,...)"
  CLI.puts "#{prog} list (scripts|html)"
  CLI.puts "#{prog} build scripts"

when /template from (.+) to (.+) with (.+)/
  tfile = Regexp.last_match(1)
  tdir = Regexp.last_match(2)
  basename = File.basename(tfile)
  new_file = File.join(tdir, basename)
  if File.exist?(new_file)
    warn "--- Already exists: #{new_file}"
    exit 0
  end

  tvals = Regexp.last_match(3).split(',').map(&:strip).map { |kv| kv.split('=').map(&:strip) }
  tmpl = File.read(tfile)
  FileUtils.mkdir_p(tdir)
  new_content = tvals.each_with_object(tmpl) do |(k, v), str|
    str.gsub!("{#{k}}", v)
  end

  File.write(new_file, new_content)
  warn "--- Wrote: #{new_file}"

when /download pure.css to (.+)/
  dir = Regexp.last_match(1)
  warn '--- No need to update: pure.css' unless FILES.download_pure_css(dir)

when 'build settings'
  BUILD.settings

when 'build'
  BUILD.static

when /build file (.+)/
  BUILD.static([Regexp.last_match(1)]).each do |file|
    puts file
  end

when 'build rename'
  public_files = FILES.find(BUILD.dirname).each_with_object({}) do |fname, memo|
    memo[FILES.key_name(fname)] = FILES.info(fname)
  end

  Dir.chdir(BUILD.dirname) do
    public_files.each do |key, info|
      case key
      when /\.html$/
        true
      else
        warn "--- Changing file name: #{key} -> #{info[:public_path]}"
        File.rename(".#{key}", ".#{info[:public_path]}")
        next
      end # case

      warn "--- Changing static file paths in: #{key} -> #{info[:public_path]}"
      content = File.read(File.join('.', key))
      new_content = content.gsub(/(src|href)="([^"]+)"/) do |x|
        attr = Regexp.last_match(1)
        old_path = Regexp.last_match(2)
        path_info = public_files[File.expand_path("./#{old_path}", Dir.pwd).sub(Dir.pwd, '')]
        if path_info
          %(#{attr}="#{path_info[:public_path]}")
        else
          x
        end
      end
      File.write(File.join('.', info[:public_path]), new_content)
      File.unlink(File.join('.', key))
    end
  end

  File.write(PUBLIC_FILES_JSON, JSON.pretty_generate(public_files))
  warn "--- Wrote: #{PUBLIC_FILES_JSON}"

when 'upload'
  files = FILES.upload(FILES.find(BUILD.dirname))
  puts ''
  files.each { |file| puts file }

when 'list scripts'
  BUILD.scripts_list.each { |f| puts f }
when 'list html'
  BUILD.html_list.each { |f| puts f }

when 'build scripts'
  BUILD.scripts

when /upload file (.+)/
  files = FILES.upload([Regexp.last_match(1)])
  puts ''
  files.each { |file| puts file }

else
  warn "!!! Unknown command: #{cmd}"
  exit 1
end # case
